# Battleship Game Implementation Plan

## Goal and Requirements

Convert the existing Netflix clone application into a Battleship game application for use at a conference booth. The application will have two main components:

1. **Game Board (Right Side - 50% of UI)**

   - Display a 10x10 grid-based battleship board
   - Show coordinates
   - Display hit/miss markers
   - Driven by database state
   - Allow players to make guesses
   - Support game reset functionality
   - Game history dropdown showing all past games with timestamps
   - Simple CSS animations for hits/misses
   - Simple game completion popup

2. **Leaderboard (Left Side - 50% of UI)**
   - Display player names
   - Show scores (1 point per hit, 0 points per miss)
   - Persist scores across game resets
   - Track multiple game attempts per player
   - Ranked by total hits across all games

## Current Implementation

### Database Structure

- PostgreSQL database named 'gitpodflix'
- Single `movies` table with columns:
  - id (SERIAL PRIMARY KEY)
  - title (VARCHAR)
  - description (TEXT)
  - release_year (INTEGER)
  - rating (DECIMAL)
  - image_url (VARCHAR)
  - created_at/updated_at timestamps

### Backend (Catalog Service)

- Express.js server running on port 3001
- Current endpoints:
  - GET /api/movies - Fetch all movies
  - POST /api/movies/seed - Seed database with sample movies
  - POST /api/movies/clear - Clear all movies
- Uses pg (node-postgres) for database connectivity
- Environment configuration for database connection

### Frontend

- React application with Vite
- Current structure:
  - src/
    - components/
    - services/
    - styles/
    - App.jsx
    - main.jsx
- Uses Tailwind CSS for styling
- Currently displays movie catalog with images and details

## Implementation Plan

### 1. Database Schema Changes

#### Simplified Single Table Structure:

```sql
CREATE TABLE game_state (
    id SERIAL PRIMARY KEY,
    game_id VARCHAR(50) NOT NULL,
    game_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    player_name VARCHAR(255) NOT NULL,
    x_coordinate INTEGER NOT NULL,
    y_coordinate INTEGER NOT NULL,
    is_hit BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

This single table will store:

- Game ID (to track different game sessions)
- Game timestamp (for history display)
- Player name
- Coordinates of guesses
- Whether the guess was a hit
- Timestamp of the guess

The leaderboard can be generated by grouping and counting hits per player.

### 2. Backend API Changes

#### Simplified Endpoints:

```typescript
// Get game state
GET /api/game/:gameId
- Returns all guesses for a specific game
- If gameId doesn't exist, returns empty array (new game)

// Get game history
GET /api/games
- Returns list of all games with timestamps

// Make a guess
POST /api/game/guess
- Body: { gameId: string, playerName: string, x: number, y: number }
- Returns: { isHit: boolean }
```

### 3. Frontend Changes

#### Core Components:

```jsx
// Game Board Component
<GameBoard>
  - 10x10 grid display
  - Coordinate system
  - Hit/miss markers with simple CSS animations
  - Click handlers for guesses
  - Game history dropdown (showing all past games)
  - New game button
  - Simple game completion popup

// Leaderboard Component
<Leaderboard>
  - Player list with scores
  - Calculated from game state
  - Sorted by total hits
```

#### Ship Configuration:

```typescript
// ships.config.ts
export const SHIPS = [
  { name: "Carrier", size: 5 },
  { name: "Battleship", size: 4 },
  { name: "Cruiser", size: 3 },
  { name: "Submarine", size: 3 },
  { name: "Destroyer", size: 2 },
];
```

### 4. State Management

#### Simplified State:

```typescript
interface GameState {
  gameId: string;
  gameTimestamp: string;
  board: {
    guesses: Array<{
      x: number;
      y: number;
      isHit: boolean;
      playerName: string;
    }>;
  };
  leaderboard: Array<{
    playerName: string;
    score: number;
  }>;
  gameHistory: Array<{
    gameId: string;
    timestamp: string;
  }>;
}
```

### 5. Implementation Steps

1. **Database Migration**

   - Create new game_state table
   - Remove old movies table

2. **Backend Implementation**

   - Create new API endpoints
   - Implement basic game logic
   - Add simple hit detection

3. **Frontend Implementation**
   - Create game board component
   - Create leaderboard component
   - Implement game controls
   - Add state management
   - Add simple CSS animations
   - Implement game history dropdown

### 6. Files to Modify

1. **Database**

   - Create new migration file for game_state table
   - Remove old movie-related migrations

2. **Backend**

   - Update `backend/catalog/src/index.ts`
   - Add game logic for hit detection

3. **Frontend**
   - Update `frontend/src/App.jsx`
   - Create new components in `frontend/src/components/`
   - Update API service in `frontend/src/services/`
   - Create ships configuration file
   - Add simple CSS animations

### 7. Creative Decisions

1. **Visual Design**

   - Retro arcade theme
   - Simple CSS animations for hits/misses
   - Clean, intuitive interface
   - Minimal external dependencies

2. **Game Mechanics**

   - Single-player game against computer
   - Client-side ship placement
   - Client-side hit detection
   - No player name validation
   - Simple game completion detection

3. **UI/UX**
   - Simple CSS animations
   - Clear visual feedback for actions
   - Easy-to-use game controls
   - Intuitive leaderboard display
   - Show all game history without limits

### 8. Implementation Checklist

1. **Database Setup**

   - [ ] Create new migration file for game_state table
   - [ ] Remove old movies table migration
   - [ ] Update database connection configuration
   - [ ] Test database connection

2. **Backend API Implementation**

   - [ ] Create GET /api/game/:gameId endpoint
   - [ ] Create GET /api/games endpoint
   - [ ] Create POST /api/game/guess endpoint
   - [ ] Implement hit detection logic
   - [ ] Add error handling
   - [ ] Test all endpoints

3. **Frontend Core Setup**

   - [ ] Create ships.config.ts
   - [ ] Set up game state management
   - [ ] Create API service for game endpoints
   - [ ] Set up CSS animations
   - [ ] Create basic layout structure

4. **Game Board Component**

   - [ ] Create 10x10 grid layout
   - [ ] Implement coordinate system
   - [ ] Add click handlers for guesses
   - [ ] Create hit/miss markers
   - [ ] Add CSS animations for hits
   - [ ] Add CSS animations for misses
   - [ ] Implement ship placement logic
   - [ ] Add ship hit detection
   - [ ] Create game completion detection
   - [ ] Add game completion popup

5. **Game History Features**

   - [ ] Create game history dropdown
   - [ ] Add timestamp display
   - [ ] Implement game switching
   - [ ] Add new game button
   - [ ] Create game ID generation
   - [ ] Add game state persistence

6. **Leaderboard Component**

   - [ ] Create leaderboard layout
   - [ ] Implement score calculation
   - [ ] Add player name display
   - [ ] Create score sorting
   - [ ] Add total hits display
   - [ ] Implement real-time updates

7. **Styling and Theme**

   - [ ] Set up retro arcade theme
   - [ ] Create color scheme
   - [ ] Style game board
   - [ ] Style leaderboard
   - [ ] Style game history dropdown
   - [ ] Style buttons and controls
   - [ ] Add responsive design
   - [ ] Create hit/miss animations
   - [ ] Style game completion popup

8. **Game Logic**

   - [ ] Implement random ship placement
   - [ ] Add ship collision detection
   - [ ] Create hit validation
   - [ ] Implement score tracking
   - [ ] Add game state management
   - [ ] Create game reset logic

9. **UI/UX Improvements**

   - [ ] Add loading states
   - [ ] Create error messages
   - [ ] Add success feedback
   - [ ] Implement smooth transitions
   - [ ] Add hover effects
   - [ ] Create active states
   - [ ] Add focus states

10. **Testing and Debugging**

    - [ ] Test ship placement
    - [ ] Test hit detection
    - [ ] Test score calculation
    - [ ] Test game history
    - [ ] Test leaderboard updates
    - [ ] Test game reset
    - [ ] Test error handling
    - [ ] Test edge cases

11. **Documentation**

    - [ ] Document API endpoints
    - [ ] Add code comments
    - [ ] Create README updates
    - [ ] Document game rules
    - [ ] Add setup instructions

12. **Final Steps**
    - [ ] Remove old movie-related code
    - [ ] Clean up unused files
    - [ ] Optimize bundle size
    - [ ] Check for console errors
    - [ ] Verify all features
    - [ ] Final testing
    - [ ] Deploy changes
